\documentclass{article}\usepackage{noweb}\pagestyle{noweb}\noweboptions{}\begin{document}\nwfilename{bench.nw}\nwbegindocs{0}\section{Benchmarking Program}% ===> this file was generated automatically by noweave --- better not edit it
This section describes the usage of the benchmarking program and its
source code.
XXX what does the benchmark program do?
The structure of the source file is listed below.
\nwenddocs{}\nwbegincode{1}\sublabel{NW408Gwv-3XORfx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3XORfx-1}}}\moddef{bench.cpp~{\nwtagstyle{}\subpageref{NW408Gwv-3XORfx-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cstdint>
#include <sycl/sycl.hpp>
#include <omp.h>
\LA{}Additional headers~{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}\RA{}
\LA{}Macro definitions~{\nwtagstyle{}\subpageref{NW408Gwv-3Yh66L-1}}\RA{}
\LA{}Type definitions~{\nwtagstyle{}\subpageref{NW408Gwv-2eQ5X5-1}}\RA{}
\LA{}Function prototypes~{\nwtagstyle{}\subpageref{NW408Gwv-G7sOC-1}}\RA{}
\LA{}Global variables~{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-1}}\RA{}
\LA{}Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}\RA{}
\nwindexdefn{\nwixident{main}}{main}{NW408Gwv-3XORfx-1}\nwindexdefn{\nwixident{argc}}{argc}{NW408Gwv-3XORfx-1}\nwindexdefn{\nwixident{argv}}{argv}{NW408Gwv-3XORfx-1}int \nwlinkedidentc{main}{NW408Gwv-3XORfx-1}(int \nwlinkedidentc{argc}{NW408Gwv-3XORfx-1}, const char **\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1})
\{
        \LA{}Process arguments~{\nwtagstyle{}\subpageref{NW408Gwv-3D46Ec-1}}\RA{}
        \LA{}Possibly initialize dump~{\nwtagstyle{}\subpageref{NW408Gwv-45hS38-1}}\RA{}
        \LA{}Time the benchmark~{\nwtagstyle{}\subpageref{NW408Gwv-1xUPJU-1}}\RA{}
        \LA{}Print the output~{\nwtagstyle{}\subpageref{NW408Gwv-btmOb-1}}\RA{}
        \LA{}Possibly finalize dump~{\nwtagstyle{}\subpageref{NW408Gwv-1esTOw-1}}\RA{}
        return 0;
\}
\nwnotused{bench.cpp}\nwidentdefs{\\{{\nwixident{argc}}{argc}}\\{{\nwixident{argv}}{argv}}\\{{\nwixident{main}}{main}}}\nwendcode{}\nwbegindocs{2}The program supports the following hash algorithms and methods to
generate the hashes.
\nwenddocs{}\nwbegincode{3}\sublabel{NW408Gwv-2eQ5X5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-2eQ5X5-1}}}\moddef{Type definitions~{\nwtagstyle{}\subpageref{NW408Gwv-2eQ5X5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwenddeflinemarkup
enum \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1} \{SHA224, SHA256, BLAKE3\};
enum \nwlinkedidentc{method}{NW408Gwv-20zlE5-1} \{SERIAL, OPENMP, SYCL_CPU, SYCL_GPU\};
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{method}}{method}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-2eQ5X5-1}\nwindexuse{\nwixident{method}}{method}{NW408Gwv-2eQ5X5-1}\nwendcode{}\nwbegindocs{4}The following {\Tt{}printf\nwendquote} template is used for printing output to the
standard output.
\nwenddocs{}\nwbegincode{5}\sublabel{NW408Gwv-3Yh66L-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3Yh66L-1}}}\moddef{Macro definitions~{\nwtagstyle{}\subpageref{NW408Gwv-3Yh66L-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{\relax}{NW408Gwv-3Yh66L-2}\nwenddeflinemarkup
#define OUTPUT_TEMPLATE "\nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1} =\\t%u\\t" \\
        "\nwlinkedidentc{num_blocks}{NW408Gwv-20zlE5-1} =\\t%u\\t" \\
        "\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1} =\\t%s\\t" \\
        "runner =\\t%s\\t" \\
        "\nwlinkedidentc{elapsed}{NW408Gwv-1xUPJU-1} (s) =\\t%f\\n"
\nwalsodefined{\\{NW408Gwv-3Yh66L-2}}\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{elapsed}}{elapsed}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}\\{{\nwixident{num{\_}blocks}}{num:unblocks}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-3Yh66L-1}\nwindexuse{\nwixident{elapsed}}{elapsed}{NW408Gwv-3Yh66L-1}\nwindexuse{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-3Yh66L-1}\nwindexuse{\nwixident{num{\_}blocks}}{num:unblocks}{NW408Gwv-3Yh66L-1}\nwendcode{}\nwbegindocs{6}\nwdocspar
%I didn't end up doing this
%.PP
%If enabled at compile-time, the program will print its hashes on the
%standard error.
%.
%This is intended for debugging purposes.
%.
%It can be enabled by passing PRINT_HASHES=1 to Make when compiling.
\nwenddocs{}\nwbegindocs{7}\subsection{Argument Processing}
This subsection details the code for processing {\Tt{}\nwlinkedidentq{argv}{NW408Gwv-3XORfx-1}\nwendquote}.
The arguments listed above are stored in the following global variables,
respectively.
Algorithms and methods are stored using enumerations defined earlier.
\nwenddocs{}\nwbegincode{8}\sublabel{NW408Gwv-20zlE5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-1}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{\relax}{NW408Gwv-20zlE5-2}\nwenddeflinemarkup
\nwindexdefn{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-20zlE5-1}static unsigned \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1};
\nwindexdefn{\nwixident{num{\_}blocks}}{num:unblocks}{NW408Gwv-20zlE5-1}static unsigned \nwlinkedidentc{num_blocks}{NW408Gwv-20zlE5-1};
\nwindexdefn{\nwixident{algorithm}}{algorithm}{NW408Gwv-20zlE5-1}static enum \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1} \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1};
\nwindexdefn{\nwixident{method}}{method}{NW408Gwv-20zlE5-1}static enum \nwlinkedidentc{method}{NW408Gwv-20zlE5-1} \nwlinkedidentc{method}{NW408Gwv-20zlE5-1};
\nwalsodefined{\\{NW408Gwv-20zlE5-2}\\{NW408Gwv-20zlE5-3}\\{NW408Gwv-20zlE5-4}}\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}\\{{\nwixident{method}}{method}}\\{{\nwixident{num{\_}blocks}}{num:unblocks}}}\nwendcode{}\nwbegindocs{9}If the incorrect number of arguments were given, then we print an error
message and exit.
Currently, we are assuming that the user will have access to the
documentation and will be able to find the usage information.
\nwenddocs{}\nwbegincode{10}\sublabel{NW408Gwv-3D46Ec-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3D46Ec-1}}}\moddef{Process arguments~{\nwtagstyle{}\subpageref{NW408Gwv-3D46Ec-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{\relax}{NW408Gwv-3D46Ec-2}\nwenddeflinemarkup
if (\nwlinkedidentc{argc}{NW408Gwv-3XORfx-1} != 5) \{
        fprintf(stderr, "%s: incorrect number of arguments.\\n", \nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}[0]);
        return 1;
\}
\nwalsodefined{\\{NW408Gwv-3D46Ec-2}}\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentuses{\\{{\nwixident{argc}}{argc}}\\{{\nwixident{argv}}{argv}}}\nwindexuse{\nwixident{argc}}{argc}{NW408Gwv-3D46Ec-1}\nwindexuse{\nwixident{argv}}{argv}{NW408Gwv-3D46Ec-1}\nwendcode{}\nwbegindocs{11}Processing each argument takes several function calls.
Also, if there is an error processing the arguments, we want to exit
with an error.
The below functions will handle these tasks.
They both take {\Tt{}\nwlinkedidentq{argv}{NW408Gwv-3XORfx-1}\nwendquote} and the argument within {\Tt{}\nwlinkedidentq{argv}{NW408Gwv-3XORfx-1}\nwendquote} to parse.
The {\Tt{}\nwlinkedidentq{parse{\_}enumerator}{NW408Gwv-RUfgA-2}\nwendquote} function also takes an array of valid enumerators
and the number of valid enumerators; the parsed value is the index of
the enumerator within the array.
Both functions return the parsed value.
\nwenddocs{}\nwbegincode{12}\sublabel{NW408Gwv-G7sOC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-G7sOC-1}}}\moddef{Function prototypes~{\nwtagstyle{}\subpageref{NW408Gwv-G7sOC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{\relax}{NW408Gwv-G7sOC-2}\nwenddeflinemarkup
static unsigned \nwlinkedidentc{parse_unsigned}{NW408Gwv-RUfgA-1}(const char **\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, int arg_num);
static int \nwlinkedidentc{parse_enumerator}{NW408Gwv-RUfgA-2}(const char **\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, int arg_num,
                const char **enumerators, const unsigned num_enumerators);
\nwalsodefined{\\{NW408Gwv-G7sOC-2}}\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentuses{\\{{\nwixident{argv}}{argv}}\\{{\nwixident{parse{\_}enumerator}}{parse:unenumerator}}\\{{\nwixident{parse{\_}unsigned}}{parse:ununsigned}}}\nwindexuse{\nwixident{argv}}{argv}{NW408Gwv-G7sOC-1}\nwindexuse{\nwixident{parse{\_}enumerator}}{parse:unenumerator}{NW408Gwv-G7sOC-1}\nwindexuse{\nwixident{parse{\_}unsigned}}{parse:ununsigned}{NW408Gwv-G7sOC-1}\nwendcode{}\nwbegindocs{13}The algorithm and method enumerations both need an array of enumerators
for {\Tt{}\nwlinkedidentq{parse{\_}enumerator}{NW408Gwv-RUfgA-2}\nwendquote}.
The order of strings within the array {\tt must} match the order of
enumerators within the enumeration definition.
\nwenddocs{}\nwbegincode{14}\sublabel{NW408Gwv-20zlE5-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-2}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-20zlE5-1}{NW408Gwv-20zlE5-3}\nwenddeflinemarkup
static const char *algorithms[] = \{"sha224", "sha256", "blake3"\};
static const char *methods[] = \{"serial", "openmp", "sycl-cpu", "sycl-gpu"\};
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{15}It will be useful to have a macro to take the length of an array.
\nwenddocs{}\nwbegincode{16}\sublabel{NW408Gwv-3Yh66L-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3Yh66L-2}}}\moddef{Macro definitions~{\nwtagstyle{}\subpageref{NW408Gwv-3Yh66L-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-3Yh66L-1}{\relax}\nwenddeflinemarkup
#define LENGTH(arr) (sizeof(arr) / sizeof((arr)[0]))
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{17}C++ wants additional casts for enumerators.
\nwenddocs{}\nwbegincode{18}\sublabel{NW408Gwv-3D46Ec-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3D46Ec-2}}}\moddef{Process arguments~{\nwtagstyle{}\subpageref{NW408Gwv-3D46Ec-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-3D46Ec-1}{\relax}\nwenddeflinemarkup
\nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1} = \nwlinkedidentc{parse_unsigned}{NW408Gwv-RUfgA-1}(\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, 1);
\nwlinkedidentc{num_blocks}{NW408Gwv-20zlE5-1} = \nwlinkedidentc{parse_unsigned}{NW408Gwv-RUfgA-1}(\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, 2);
\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1} = (enum \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1})
        \nwlinkedidentc{parse_enumerator}{NW408Gwv-RUfgA-2}(\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, 3, algorithms, LENGTH(algorithms));
\nwlinkedidentc{method}{NW408Gwv-20zlE5-1} = (enum \nwlinkedidentc{method}{NW408Gwv-20zlE5-1})\nwlinkedidentc{parse_enumerator}{NW408Gwv-RUfgA-2}(\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, 4, methods, LENGTH(algorithms));
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{argv}}{argv}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}\\{{\nwixident{method}}{method}}\\{{\nwixident{num{\_}blocks}}{num:unblocks}}\\{{\nwixident{parse{\_}enumerator}}{parse:unenumerator}}\\{{\nwixident{parse{\_}unsigned}}{parse:ununsigned}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-3D46Ec-2}\nwindexuse{\nwixident{argv}}{argv}{NW408Gwv-3D46Ec-2}\nwindexuse{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-3D46Ec-2}\nwindexuse{\nwixident{method}}{method}{NW408Gwv-3D46Ec-2}\nwindexuse{\nwixident{num{\_}blocks}}{num:unblocks}{NW408Gwv-3D46Ec-2}\nwindexuse{\nwixident{parse{\_}enumerator}}{parse:unenumerator}{NW408Gwv-3D46Ec-2}\nwindexuse{\nwixident{parse{\_}unsigned}}{parse:ununsigned}{NW408Gwv-3D46Ec-2}\nwendcode{}\nwbegindocs{19}Parsing integers is simple using C’s {\Tt{}sscanf\nwendquote}.
If it does not match any inputs items, which is the only case for failure
here, it returns {\Tt{}EOF\nwendquote}.
It cannot fail before the first match, because there is only one item
to match.
\nwenddocs{}\nwbegincode{20}\sublabel{NW408Gwv-RUfgA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\moddef{Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{\relax}{NW408Gwv-RUfgA-2}\nwenddeflinemarkup
\nwindexdefn{\nwixident{parse{\_}unsigned}}{parse:ununsigned}{NW408Gwv-RUfgA-1}static unsigned \nwlinkedidentc{parse_unsigned}{NW408Gwv-RUfgA-1}(const char **\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, int arg_num)
\{
        int rc;
        unsigned result;
        rc = sscanf(\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}[arg_num], "%u", &result);
        if (rc == EOF) \{
                fprintf(stderr, "%s: could not parse “%s” as an unsigned "
                        "integer\\n", \nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}[0], \nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}[arg_num]);
                exit(1);
        \}
        return result;
\}
\nwalsodefined{\\{NW408Gwv-RUfgA-2}\\{NW408Gwv-RUfgA-3}\\{NW408Gwv-RUfgA-4}\\{NW408Gwv-RUfgA-5}\\{NW408Gwv-RUfgA-6}\\{NW408Gwv-RUfgA-7}}\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{parse{\_}unsigned}}{parse:ununsigned}}}\nwidentuses{\\{{\nwixident{argv}}{argv}}}\nwindexuse{\nwixident{argv}}{argv}{NW408Gwv-RUfgA-1}\nwendcode{}\nwbegindocs{21}Enumerators are parsed using a linear scan and C’s {\Tt{}strcmp\nwendquote}.
There are ways to make this more efficient, but it probably does not
matter.
Printing the list of enuemrators as part of the error message is
non-trivial, and possibly unnecessary.
\nwenddocs{}\nwbegincode{22}\sublabel{NW408Gwv-RUfgA-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-2}}}\moddef{Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-RUfgA-1}{NW408Gwv-RUfgA-3}\nwenddeflinemarkup
\nwindexdefn{\nwixident{parse{\_}enumerator}}{parse:unenumerator}{NW408Gwv-RUfgA-2}static int \nwlinkedidentc{parse_enumerator}{NW408Gwv-RUfgA-2}(const char **\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}, int arg_num,
                const char **enumerators, const unsigned num_enumerators)
\{
        unsigned i;
        for (i = 0; i < num_enumerators; i++)
                if (strcmp(\nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}[arg_num], enumerators[i]) == 0)
                        return i;
        fprintf(stderr, "%s: could not match “%s” to ",
                        \nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}[0], \nwlinkedidentc{argv}{NW408Gwv-3XORfx-1}[arg_num]);
        for (i = 0; i < num_enumerators - 1; i++)
                fprintf(stderr, "“%s”, ", enumerators[i]);
        fprintf(stderr, "or “%s”.\\n", enumerators[i]);
        exit(1);
        return 0;
\}
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{parse{\_}enumerator}}{parse:unenumerator}}}\nwidentuses{\\{{\nwixident{argv}}{argv}}}\nwindexuse{\nwixident{argv}}{argv}{NW408Gwv-RUfgA-2}\nwendcode{}\nwbegindocs{23}\subsection{Timing the Benchmark}
The POSIX clock interface is used to get the time before and after the
hashes are generated.
Since only a relative time is required, {\Tt{}CLOCK{\_}MONOTONIC\nwendquote} is sufficient.
The elapsed time is stored in the variable {\Tt{}\nwlinkedidentq{elapsed}{NW408Gwv-1xUPJU-1}\nwendquote}.
\nwenddocs{}\nwbegincode{24}\sublabel{NW408Gwv-1xUPJU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-1xUPJU-1}}}\moddef{Time the benchmark~{\nwtagstyle{}\subpageref{NW408Gwv-1xUPJU-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwenddeflinemarkup
double \nwlinkedidentc{elapsed}{NW408Gwv-1xUPJU-1};
struct timespec start, end;
clock_gettime(CLOCK_MONOTONIC, &start);
\LA{}Run the benchmark~{\nwtagstyle{}\subpageref{NW408Gwv-17GnJ9-1}}\RA{}
clock_gettime(CLOCK_MONOTONIC, &end);
\nwindexdefn{\nwixident{elapsed}}{elapsed}{NW408Gwv-1xUPJU-1}\nwlinkedidentc{elapsed}{NW408Gwv-1xUPJU-1} = (double)end.tv_sec - (double)start.tv_sec;
\nwlinkedidentc{elapsed}{NW408Gwv-1xUPJU-1} += ((double)end.tv_nsec - (double)start.tv_nsec) / 1e12L;
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{elapsed}}{elapsed}}}\nwendcode{}\nwbegindocs{25}\subsection{Printing the Output}
All of the variables that are needed for output have been defined.
The string names for the algorithm and method are printed instead of
their enumerator’s number.
\nwenddocs{}\nwbegincode{26}\sublabel{NW408Gwv-btmOb-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-btmOb-1}}}\moddef{Print the output~{\nwtagstyle{}\subpageref{NW408Gwv-btmOb-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwenddeflinemarkup
printf(OUTPUT_TEMPLATE, \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1}, \nwlinkedidentc{num_blocks}{NW408Gwv-20zlE5-1},
                algorithms[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}], methods[\nwlinkedidentc{method}{NW408Gwv-20zlE5-1}], \nwlinkedidentc{elapsed}{NW408Gwv-1xUPJU-1});
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{elapsed}}{elapsed}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}\\{{\nwixident{method}}{method}}\\{{\nwixident{num{\_}blocks}}{num:unblocks}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-btmOb-1}\nwindexuse{\nwixident{elapsed}}{elapsed}{NW408Gwv-btmOb-1}\nwindexuse{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-btmOb-1}\nwindexuse{\nwixident{method}}{method}{NW408Gwv-btmOb-1}\nwindexuse{\nwixident{num{\_}blocks}}{num:unblocks}{NW408Gwv-btmOb-1}\nwendcode{}\nwbegindocs{27}\subsection{Dumping Hashes}
If the {\Tt{}DUMP\nwendquote} preprocessor macro is defined, the program should dump
its hashes to a file. This is for validating that the generated hashes
are correct.

See the check-dumps.sh script to compare the hashes side-by-side.
\nwenddocs{}\nwbegincode{28}\sublabel{NW408Gwv-20zlE5-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-3}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-20zlE5-2}{NW408Gwv-20zlE5-4}\nwenddeflinemarkup
#ifdef DUMP
static FILE *dump_stream;
#endif
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegincode{29}\sublabel{NW408Gwv-45hS38-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-45hS38-1}}}\moddef{Possibly initialize dump~{\nwtagstyle{}\subpageref{NW408Gwv-45hS38-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwenddeflinemarkup
#ifdef DUMP
dump_stream = fopen("bench-hashes.dat", "w");
#endif
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegincode{30}\sublabel{NW408Gwv-1esTOw-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-1esTOw-1}}}\moddef{Possibly finalize dump~{\nwtagstyle{}\subpageref{NW408Gwv-1esTOw-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwenddeflinemarkup
#ifdef DUMP
fclose(dump_stream);
#endif
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{31}All of the generators will call {\Tt{}\nwlinkedidentq{dump}{NW408Gwv-RUfgA-3}\nwendquote}. When dumping is enabled, it
will be an actual function. Otherwise, it will be a macro that expands
to nothing.
\nwenddocs{}\nwbegincode{32}\sublabel{NW408Gwv-RUfgA-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-3}}}\moddef{Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-RUfgA-2}{NW408Gwv-RUfgA-4}\nwenddeflinemarkup
#ifdef DUMP
\nwindexdefn{\nwixident{dump}}{dump}{NW408Gwv-RUfgA-3}static void \nwlinkedidentc{dump}{NW408Gwv-RUfgA-3}(unsigned char *buffer, size_t num_hashes, size_t hash_size)
\{
        \LA{}Dump hashes in \code{}buffer\edoc{}~{\nwtagstyle{}\subpageref{NW408Gwv-QdW2c-1}}\RA{}
\}
#else
#define \nwlinkedidentc{dump}{NW408Gwv-RUfgA-3}(x, y, z) /* \nwlinkedidentc{dump}{NW408Gwv-RUfgA-3} */
#endif
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{dump}}{dump}}}\nwendcode{}\nwbegindocs{33}Each hash is printed in hexadecimal, on its own line.
TODO: it might be useful to print the index along with the hash.
\nwenddocs{}\nwbegincode{34}\sublabel{NW408Gwv-QdW2c-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-QdW2c-1}}}\moddef{Dump hashes in \code{}buffer\edoc{}~{\nwtagstyle{}\subpageref{NW408Gwv-QdW2c-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-RUfgA-3}}\nwenddeflinemarkup
unsigned i, j;
for (i = 0; i < num_hashes; i++) \{
        for (j = 0; j < hash_size; j++) \{
                fprintf(dump_stream, "%02x", buffer[i * hash_size + j]);
        \}
        fprintf(dump_stream, "\\n");
\}
\nwused{\\{NW408Gwv-RUfgA-3}}\nwendcode{}\nwbegindocs{35}\subsection{Supporting Different Hash Algorithms}
The goal is to support several different hash algorithms and compare
their performance.
The following function will be used to dispatch the correct hash
function according the algorithm, and ensure the result is written to
{\Tt{}buf[slot]\nwendquote}.
The algorithm must be passed explicitly, otherwise the SYCL compiler
will complain.
\nwenddocs{}\nwbegincode{36}\sublabel{NW408Gwv-G7sOC-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-G7sOC-2}}}\moddef{Function prototypes~{\nwtagstyle{}\subpageref{NW408Gwv-G7sOC-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-G7sOC-1}{\relax}\nwenddeflinemarkup
static void \nwlinkedidentc{run_hash}{NW408Gwv-RUfgA-4}(enum \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1} \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}, uint64_t input,
                unsigned char *buf, unsigned slot);
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{run{\_}hash}}{run:unhash}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-G7sOC-2}\nwindexuse{\nwixident{run{\_}hash}}{run:unhash}{NW408Gwv-G7sOC-2}\nwendcode{}\nwbegindocs{37}The downside of this approach is that the algorithm is checked every
time a hash is generated.
This could be avoided by calling a function that is set to the appropriate
hash function, but SYCL does not support calling function pointers in
its kernels.
\nwenddocs{}\nwbegincode{38}\sublabel{NW408Gwv-RUfgA-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-4}}}\moddef{Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-RUfgA-3}{NW408Gwv-RUfgA-5}\nwenddeflinemarkup
\nwindexdefn{\nwixident{run{\_}hash}}{run:unhash}{NW408Gwv-RUfgA-4}static void \nwlinkedidentc{run_hash}{NW408Gwv-RUfgA-4}(enum \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1} \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}, uint64_t input,
                unsigned char *buf, unsigned slot)
\{
        switch (\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}) \{
        case SHA224:
                \LA{}Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with SHA-224~{\nwtagstyle{}\subpageref{NW408Gwv-JGDkX-1}}\RA{}
                break;
        case SHA256:
                \LA{}Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with SHA-256~{\nwtagstyle{}\subpageref{NW408Gwv-1xDrLN-1}}\RA{}
                break;
        case BLAKE3:
                \LA{}Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with BLAKE3~{\nwtagstyle{}\subpageref{NW408Gwv-3e8ivs-1}}\RA{}
                break;
        \}
\}
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{run{\_}hash}}{run:unhash}}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-RUfgA-4}\nwendcode{}\nwbegindocs{39}\subsection{Supporting Different Running Methods}
The other feature of this program is that it supports several drivers
to run the has generation code.
Some runners may require common, local variables.
\nwenddocs{}\nwbegincode{40}\sublabel{NW408Gwv-17GnJ9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-17GnJ9-1}}}\moddef{Run the benchmark~{\nwtagstyle{}\subpageref{NW408Gwv-17GnJ9-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-1xUPJU-1}}\nwenddeflinemarkup
\LA{}Local declarations for the runner~{\nwtagstyle{}\subpageref{NW408Gwv-4aufMS-1}}\RA{}
switch (\nwlinkedidentc{method}{NW408Gwv-20zlE5-1}) \{
case SERIAL:
        \LA{}Run benchmark in serial~{\nwtagstyle{}\subpageref{NW408Gwv-gU9OG-1}}\RA{}
        break;
case SYCL_CPU:
        \LA{}Run benchmark with SYCL on the CPU~{\nwtagstyle{}\subpageref{NW408Gwv-3XaOMG-1}}\RA{}
        break;
case SYCL_GPU:
        \LA{}Run benchmark with SYCL on the GPU~{\nwtagstyle{}\subpageref{NW408Gwv-3XaQo0-1}}\RA{}
        break;
case OPENMP:
        \LA{}Run benchmark with OpenMP~{\nwtagstyle{}\subpageref{NW408Gwv-2Cc2Fr-1}}\RA{}
        break;
\}
\LA{}Delete any local declarations~{\nwtagstyle{}\subpageref{NW408Gwv-2CzAcv-1}}\RA{}
\nwused{\\{NW408Gwv-1xUPJU-1}}\nwidentuses{\\{{\nwixident{method}}{method}}}\nwindexuse{\nwixident{method}}{method}{NW408Gwv-17GnJ9-1}\nwendcode{}\nwbegindocs{41}Something that all of the runners will need is a buffer to write the
hashes to.
This requires knowing the size of each hash in bytes.
They are stored in the {\Tt{}digest{\_}size\nwendquote} array.
\nwenddocs{}\nwbegincode{42}\sublabel{NW408Gwv-4aufMS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4aufMS-1}}}\moddef{Local declarations for the runner~{\nwtagstyle{}\subpageref{NW408Gwv-4aufMS-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-17GnJ9-1}}\nwenddeflinemarkup
unsigned char *output_buffer =
                new unsigned char[\nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1} * digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}]];
\nwused{\\{NW408Gwv-17GnJ9-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-4aufMS-1}\nwindexuse{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-4aufMS-1}\nwendcode{}\nwbegincode{43}\sublabel{NW408Gwv-2CzAcv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-2CzAcv-1}}}\moddef{Delete any local declarations~{\nwtagstyle{}\subpageref{NW408Gwv-2CzAcv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-17GnJ9-1}}\nwenddeflinemarkup
delete[] output_buffer;
\nwused{\\{NW408Gwv-17GnJ9-1}}\nwendcode{}\nwbegincode{44}\sublabel{NW408Gwv-20zlE5-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-4}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW408Gwv-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-20zlE5-3}{\relax}\nwenddeflinemarkup
static const unsigned digest_size[] = \{28u, 32u, 32u\};
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{45}\subsection{Running in Serial}
Running in serial is simple.
\nwenddocs{}\nwbegincode{46}\sublabel{NW408Gwv-gU9OG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-gU9OG-1}}}\moddef{Run benchmark in serial~{\nwtagstyle{}\subpageref{NW408Gwv-gU9OG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-17GnJ9-1}}\nwenddeflinemarkup
for (uint64_t i = 0; i < \nwlinkedidentc{num_blocks}{NW408Gwv-20zlE5-1}; i++) \{
        for (uint64_t j = 0; j < \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1}; j++) \{
                \nwlinkedidentc{run_hash}{NW408Gwv-RUfgA-4}(\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}, i * \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1} + j, output_buffer, j);
        \}
        \nwlinkedidentc{dump}{NW408Gwv-RUfgA-3}(output_buffer, \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1}, digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}]);
\}
\nwused{\\{NW408Gwv-17GnJ9-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{dump}}{dump}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}\\{{\nwixident{num{\_}blocks}}{num:unblocks}}\\{{\nwixident{run{\_}hash}}{run:unhash}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-gU9OG-1}\nwindexuse{\nwixident{dump}}{dump}{NW408Gwv-gU9OG-1}\nwindexuse{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-gU9OG-1}\nwindexuse{\nwixident{num{\_}blocks}}{num:unblocks}{NW408Gwv-gU9OG-1}\nwindexuse{\nwixident{run{\_}hash}}{run:unhash}{NW408Gwv-gU9OG-1}\nwendcode{}\nwbegindocs{47}\subsection{Running with OpenMP}
The same as serial, but with an OpenMP pragma.

There are probably other ways to parallelize this.
\nwenddocs{}\nwbegincode{48}\sublabel{NW408Gwv-2Cc2Fr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-2Cc2Fr-1}}}\moddef{Run benchmark with OpenMP~{\nwtagstyle{}\subpageref{NW408Gwv-2Cc2Fr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-17GnJ9-1}}\nwenddeflinemarkup
#pragma omp parallel
for (uint64_t i = 0; i < \nwlinkedidentc{num_blocks}{NW408Gwv-20zlE5-1}; i++) \{
#pragma omp for
        for (uint64_t j = 0; j < \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1}; j++) \{
                \nwlinkedidentc{run_hash}{NW408Gwv-RUfgA-4}(\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}, i * \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1} + j, output_buffer, j);
        \}
        \nwlinkedidentc{dump}{NW408Gwv-RUfgA-3}(output_buffer, \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1}, digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}]);
\}
\nwused{\\{NW408Gwv-17GnJ9-1}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{dump}}{dump}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}\\{{\nwixident{num{\_}blocks}}{num:unblocks}}\\{{\nwixident{run{\_}hash}}{run:unhash}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-2Cc2Fr-1}\nwindexuse{\nwixident{dump}}{dump}{NW408Gwv-2Cc2Fr-1}\nwindexuse{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-2Cc2Fr-1}\nwindexuse{\nwixident{num{\_}blocks}}{num:unblocks}{NW408Gwv-2Cc2Fr-1}\nwindexuse{\nwixident{run{\_}hash}}{run:unhash}{NW408Gwv-2Cc2Fr-1}\nwendcode{}\nwbegindocs{49}\subsection{Running with SYCL}
\nwenddocs{}\nwbegindocs{50}The following function looks for devices that match the selector,
and returns queues for them. If {\Tt{}use{\_}all\nwendquote} is false, then only on queue
is returned.
\nwenddocs{}\nwbegincode{51}\sublabel{NW408Gwv-RUfgA-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-5}}}\moddef{Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-RUfgA-4}{NW408Gwv-RUfgA-6}\nwenddeflinemarkup
template<class Selector>
\nwindexdefn{\nwixident{make{\_}queues}}{make:unqueues}{NW408Gwv-RUfgA-5}static std::vector<sycl::queue> \nwlinkedidentc{make_queues}{NW408Gwv-RUfgA-5}(Selector sel, bool use_all)
\{
        sycl::platform p(sel);
        std::vector<sycl::device> ds = p.get_devices();
        if (!use_all) \{
                for (unsigned i = 1; i < ds.size(); i++) \{
                        ds.pop_back();
                \}
        \}
        std::vector<sycl::queue> result;
        for (sycl::device d : ds) \{
                sycl::queue q(d);
                result.push_back(q);
        \}
        return result;
\}
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{make{\_}queues}}{make:unqueues}}}\nwendcode{}\nwbegindocs{52}The following function creates buffers for each device in the given
vector. If allocation fails, the program exits with an error.

TODO: better error message
\nwenddocs{}\nwbegincode{53}\sublabel{NW408Gwv-RUfgA-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-6}}}\moddef{Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-RUfgA-5}{NW408Gwv-RUfgA-7}\nwenddeflinemarkup
\nwindexdefn{\nwixident{alloc{\_}buffers}}{alloc:unbuffers}{NW408Gwv-RUfgA-6}static std::vector<unsigned char *> \nwlinkedidentc{alloc_buffers}{NW408Gwv-RUfgA-6}(std::vector<sycl::queue> qs,
                int buffer_size)
\{
        std::vector<unsigned char *> result;
        for (sycl::queue q : qs) \{
                unsigned char *b = sycl::malloc_device<unsigned char>(
                                buffer_size, q);
                if (b == nullptr) \{
                        fprintf(stderr, "sycl::malloc_device failed when "
                                        "called %u bytes were requested.\\n",
                                        buffer_size);
                        exit(1);
                \}
                result.push_back(b);
        \}
        return result;
\}
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{alloc{\_}buffers}}{alloc:unbuffers}}}\nwendcode{}\nwbegindocs{54}Running with SYCL requires a few local variables and polymorphic types.
A separate function is used to deal with this.

TODO: document {\Tt{}use{\_}all\nwendquote}.
\nwenddocs{}\nwbegincode{55}\sublabel{NW408Gwv-RUfgA-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-7}}}\moddef{Function definitions~{\nwtagstyle{}\subpageref{NW408Gwv-RUfgA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-RUfgA-6}{\relax}\nwenddeflinemarkup
template <class Selector>
\nwindexdefn{\nwixident{run{\_}sycl}}{run:unsycl}{NW408Gwv-RUfgA-7}static void \nwlinkedidentc{run_sycl}{NW408Gwv-RUfgA-7}(Selector sel, unsigned char *host_buffer, bool use_all)
\{
        std::vector<sycl::queue> qs = \nwlinkedidentc{make_queues}{NW408Gwv-RUfgA-5}(sel, use_all);
        int buffer_size = (\nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1} * digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}])
                        / qs.size();
        int hashes_per_device = \nwlinkedidentc{hashes_per_block}{NW408Gwv-20zlE5-1} / qs.size();
        std::vector<unsigned char *> buffers = \nwlinkedidentc{alloc_buffers}{NW408Gwv-RUfgA-6}(qs, buffer_size);
#pragma omp parallel if(qs.size() > 1) num_threads(qs.size())
        \{
                int t = omp_get_thread_num();
                enum \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1} alg = \nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1};
                unsigned char *host_ptr = host_buffer + buffer_size * t;
                for (uint64_t i = 0, base = 0; i < \nwlinkedidentc{num_blocks}{NW408Gwv-20zlE5-1};
                                        i++, base += hashes_per_device) \{
                        sycl::event hashes_ev = qs[t].parallel_for(sycl::range<1>(hashes_per_device), [=] (sycl::id<1> idx) \{
                                \nwlinkedidentc{run_hash}{NW408Gwv-RUfgA-4}(alg, base + idx, buffers[t], idx);
                        \});
                        sycl::event copy_ev = qs[t].memcpy(host_ptr, buffers[t], buffer_size, hashes_ev);
                        copy_ev.wait();
                        \nwlinkedidentc{dump}{NW408Gwv-RUfgA-3}(host_ptr, hashes_per_device, digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}]);
                \}
        \}
        for (unsigned i = 0; i < buffers.size(); i++) \{
                sycl::free(buffers[i], qs[i]);
        \}
\}
\nwused{\\{NW408Gwv-3XORfx-1}}\nwidentdefs{\\{{\nwixident{run{\_}sycl}}{run:unsycl}}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}\\{{\nwixident{alloc{\_}buffers}}{alloc:unbuffers}}\\{{\nwixident{dump}}{dump}}\\{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}\\{{\nwixident{make{\_}queues}}{make:unqueues}}\\{{\nwixident{num{\_}blocks}}{num:unblocks}}\\{{\nwixident{run{\_}hash}}{run:unhash}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-RUfgA-7}\nwindexuse{\nwixident{alloc{\_}buffers}}{alloc:unbuffers}{NW408Gwv-RUfgA-7}\nwindexuse{\nwixident{dump}}{dump}{NW408Gwv-RUfgA-7}\nwindexuse{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}{NW408Gwv-RUfgA-7}\nwindexuse{\nwixident{make{\_}queues}}{make:unqueues}{NW408Gwv-RUfgA-7}\nwindexuse{\nwixident{num{\_}blocks}}{num:unblocks}{NW408Gwv-RUfgA-7}\nwindexuse{\nwixident{run{\_}hash}}{run:unhash}{NW408Gwv-RUfgA-7}\nwendcode{}\nwbegindocs{56}TODO runners that set {\Tt{}use{\_}all\nwendquote} to false.
\nwenddocs{}\nwbegincode{57}\sublabel{NW408Gwv-3XaOMG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3XaOMG-1}}}\moddef{Run benchmark with SYCL on the CPU~{\nwtagstyle{}\subpageref{NW408Gwv-3XaOMG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-17GnJ9-1}}\nwenddeflinemarkup
\nwlinkedidentc{run_sycl}{NW408Gwv-RUfgA-7}(sycl::cpu_selector_v, output_buffer, true);
\nwused{\\{NW408Gwv-17GnJ9-1}}\nwidentuses{\\{{\nwixident{run{\_}sycl}}{run:unsycl}}}\nwindexuse{\nwixident{run{\_}sycl}}{run:unsycl}{NW408Gwv-3XaOMG-1}\nwendcode{}\nwbegincode{58}\sublabel{NW408Gwv-3XaQo0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3XaQo0-1}}}\moddef{Run benchmark with SYCL on the GPU~{\nwtagstyle{}\subpageref{NW408Gwv-3XaQo0-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-17GnJ9-1}}\nwenddeflinemarkup
\nwlinkedidentc{run_sycl}{NW408Gwv-RUfgA-7}(sycl::gpu_selector_v, output_buffer, true);
\nwused{\\{NW408Gwv-17GnJ9-1}}\nwidentuses{\\{{\nwixident{run{\_}sycl}}{run:unsycl}}}\nwindexuse{\nwixident{run{\_}sycl}}{run:unsycl}{NW408Gwv-3XaQo0-1}\nwendcode{}\nwbegindocs{59}\subsection{SHA-224 Hash Algorithm}
The SHA-224 algorithm used here comes from an implementation that I found
online.\footnote{\tt http://www.zedwood.com/article/cpp-sha224-function}
There are some optimizations that could be made with a custom
implementation, because we know exactly how long the message is, etc.
\nwenddocs{}\nwbegincode{60}\sublabel{NW408Gwv-4b5Gre-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}}\moddef{Additional headers~{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{\relax}{NW408Gwv-4b5Gre-2}\nwenddeflinemarkup
#include "sha224.hpp"
\nwalsodefined{\\{NW408Gwv-4b5Gre-2}\\{NW408Gwv-4b5Gre-3}\\{NW408Gwv-4b5Gre-4}\\{NW408Gwv-4b5Gre-5}\\{NW408Gwv-4b5Gre-6}}\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{61}Using this implementation requires only the following function calls.
The hash algorithms are implemented in {\Tt{}switch\nwendquote} case bodies, so a new
scope is needed to declare local variables well.
\nwenddocs{}\nwbegincode{62}\sublabel{NW408Gwv-JGDkX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-JGDkX-1}}}\moddef{Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with SHA-224~{\nwtagstyle{}\subpageref{NW408Gwv-JGDkX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-RUfgA-4}}\nwenddeflinemarkup
\{
        class SHA224 ctx;
        ctx.init();
        ctx.update((const unsigned char *)&input, sizeof(input));
        ctx.final(buf + slot * digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}]);
\}
\nwused{\\{NW408Gwv-RUfgA-4}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-JGDkX-1}\nwendcode{}\nwbegindocs{63}As it turns out {\Tt{}SYCL{\_}EXTERNAL\nwendquote} is not universal, and everything {\tt must}
be in the same translation to be portable across SYCL compilers, it seems.
Although the below strategy works, it’s bad practice and should be
replaced.
\nwenddocs{}\nwbegincode{64}\sublabel{NW408Gwv-4b5Gre-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-2}}}\moddef{Additional headers~{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-4b5Gre-1}{NW408Gwv-4b5Gre-3}\nwenddeflinemarkup
#include "sha224.cpp"
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{65}\subsection{SHA-256 Hash Algorithm}
I modified the SHA-224 implementation to be SHA-256.
I have not completely verified that it is correct.
\nwenddocs{}\nwbegincode{66}\sublabel{NW408Gwv-4b5Gre-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-3}}}\moddef{Additional headers~{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-4b5Gre-2}{NW408Gwv-4b5Gre-4}\nwenddeflinemarkup
#include "sha256.hpp"
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegincode{67}\sublabel{NW408Gwv-1xDrLN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-1xDrLN-1}}}\moddef{Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with SHA-256~{\nwtagstyle{}\subpageref{NW408Gwv-1xDrLN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-RUfgA-4}}\nwenddeflinemarkup
\{
        class SHA256 ctx;
        ctx.init();
        ctx.update((const unsigned char *)&input, sizeof(input));
        ctx.final(buf + slot * digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}]);
\}
\nwused{\\{NW408Gwv-RUfgA-4}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-1xDrLN-1}\nwendcode{}\nwbegindocs{68}See the SHA-224 section for an explanation.
\nwenddocs{}\nwbegincode{69}\sublabel{NW408Gwv-4b5Gre-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-4}}}\moddef{Additional headers~{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-4b5Gre-3}{NW408Gwv-4b5Gre-5}\nwenddeflinemarkup
#include "sha256.cpp"
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{70}\subsection{BLAKE3 Hash Algorithm}
The BLAKE3 implementation comes from the BLAKE3 reference implemenation.
It had to be modified slightly to work with C++ and SYCL.
\nwenddocs{}\nwbegincode{71}\sublabel{NW408Gwv-4b5Gre-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-5}}}\moddef{Additional headers~{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-4b5Gre-4}{NW408Gwv-4b5Gre-6}\nwenddeflinemarkup
#include "blake3.h"
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{72}The interface for BLAKE3 uses different names and arguments than SHA-2,
but functionally the same otherwise.
\nwenddocs{}\nwbegincode{73}\sublabel{NW408Gwv-3e8ivs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-3e8ivs-1}}}\moddef{Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with BLAKE3~{\nwtagstyle{}\subpageref{NW408Gwv-3e8ivs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-RUfgA-4}}\nwenddeflinemarkup
\{
        blake3_hasher hasher;
        blake3_hasher_init(&hasher);
        blake3_hasher_update(&hasher, &input, sizeof(input));
        blake3_hasher_finalize(&hasher,
                        buf + slot * digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}],
                        digest_size[\nwlinkedidentc{algorithm}{NW408Gwv-20zlE5-1}]);
\}
\nwused{\\{NW408Gwv-RUfgA-4}}\nwidentuses{\\{{\nwixident{algorithm}}{algorithm}}}\nwindexuse{\nwixident{algorithm}}{algorithm}{NW408Gwv-3e8ivs-1}\nwendcode{}\nwbegindocs{74}See the SHA-224 section for an explanation.
\nwenddocs{}\nwbegincode{75}\sublabel{NW408Gwv-4b5Gre-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-6}}}\moddef{Additional headers~{\nwtagstyle{}\subpageref{NW408Gwv-4b5Gre-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-3XORfx-1}}\nwprevnextdefs{NW408Gwv-4b5Gre-5}{\relax}\nwenddeflinemarkup
#include "blake3.cpp"
#include "blake3_dispatch.cpp"
#include "blake3_portable.cpp"
\nwused{\\{NW408Gwv-3XORfx-1}}\nwendcode{}\nwbegindocs{76}\subsection{Support Scripts}
The \mbox{run-bench.sh} script automates the collection of data using
the benchmark, and outputs the results to the file \mbox{bench-results}.
It generates SHA-256 and BLAKE3 hashes on the CPU and GPU with block
sizes and hash counts read from the standard input.
The generate-inputs.sh script, described later, generates suitable inputs.

It fails for the huge buffer sizes.
This should be investigated, but it does not appear to affect the
completion of the script or the results.
\nwenddocs{}\nwbegincode{77}\sublabel{NW408Gwv-2BcZja-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-2BcZja-1}}}\moddef{run-bench.sh~{\nwtagstyle{}\subpageref{NW408Gwv-2BcZja-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#!/bin/sh

while read -r x y
do
        ./bench $x $y sha256 openmp
        ./bench $x $y sha256 sycl-cpu
        ./bench $x $y sha256 sycl-gpu
        ./bench $x $y blake3 openmp
        ./bench $x $y blake3 sycl-cpu
        ./bench $x $y blake3 sycl-gpu
done | tee bench-results
\nwnotused{run-bench.sh}\nwendcode{}\nwbegindocs{78}\subsection{Making Graphs}
The following script can be used to convert the output of the benchmark
script to a grap(1) graph, suitable to {\tt copy} in \mbox{report.ms}.
See the report source of that file to see how to use the output of
this script.

This script needs some work, especially with selecting ticks.

Assumes 256-bit hashes.
\nwenddocs{}\nwbegincode{79}\sublabel{NW408Gwv-1OqFIM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-1OqFIM-1}}}\moddef{to-grap.sh~{\nwtagstyle{}\subpageref{NW408Gwv-1OqFIM-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#!/bin/sh
echo 'label left "Real Time" "(s)"'
echo 'label bot "Block Size"'
awk '-F\\t' '
        function tosize(n, i, suffix, suffixes) \{
                \LA{}Convert bytes to human-readable units~{\nwtagstyle{}\subpageref{NW408Gwv-9tsGB-1}}\RA{}
        \}
        BEGIN \{
                xmin = 1e12
        \}
        /openmp/ && /sha/ \{char[count] = "ci"\}
        /cpu/ && /sha/ \{char[count] = "sq"\}
        /gpu/ && /sha/ \{char[count] = "pl"\}
        /openmp/ && /blake/ \{char[count] = "bu"\}
        /cpu/ && /blake/ \{char[count] = "*D"\}
        /gpu/ && /blake/ \{char[count] = "mu"\}
        \{
                x[count] = $2
                y[count] = $10
                ymax = $10 > ymax ? $10 : ymax
                xmax = $2 > xmax ? $2 : xmax
                xmin = $2 < xmin ? $2 : xmin
                xtick[$2]++
                count++
        \}
        END \{
                printf "coord y 0, %d log x\\n", ymax + 1
                \LA{}Select and print ticks~{\nwtagstyle{}\subpageref{NW408Gwv-1ZFdQI-1}}\RA{}
                printf "\\"\\\\(sq SHA-256, CPU\\" \\"\\\\(pl SHA-256, GPU\\" " \\
                        "\\"\\\\(*D BLAKE3, CPU\\" \\"\\\\(mu BLAKE3, GPU\\" " \\
                        "\\"\\\\(ci SHA256, OMP\\" \\"\\\\(bu BLAKE3, OMP\\" " \\
                        "\\"\\" ljust at (%f,%f)\\n", xmax / 8, ymax * 0.8
                for (i = 0; i < count; i++) \{
                        if (!(i in char)) continue
                        printf "\\"\\\\(%s\\" at (%f,%f)\\n", char[i], x[i], y[i]
                \}
        \}
'
\nwnotused{to-grap.sh}\nwendcode{}\nwbegindocs{80}TODO is there an easier way to do this with gawk?
\nwenddocs{}\nwbegincode{81}\sublabel{NW408Gwv-9tsGB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-9tsGB-1}}}\moddef{Convert bytes to human-readable units~{\nwtagstyle{}\subpageref{NW408Gwv-9tsGB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-1OqFIM-1}}\nwenddeflinemarkup
suffixes[0] = "B"
suffixes[1] = "KiB"
suffixes[2] = "MiB"
suffixes[3] = "GiB"
i = 0
suffix = 0
while (n > 1024) \{
        n = n / 1024
        suffix++
\}
return sprintf("%d%s", n, suffixes[suffix])
\nwused{\\{NW408Gwv-1OqFIM-1}}\nwendcode{}\nwbegindocs{82}TODO improve this. This seems bad.
\nwenddocs{}\nwbegincode{83}\sublabel{NW408Gwv-1ZFdQI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-1ZFdQI-1}}}\moddef{Select and print ticks~{\nwtagstyle{}\subpageref{NW408Gwv-1ZFdQI-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW408Gwv-1OqFIM-1}}\nwenddeflinemarkup
printf "ticks bot out at"
len = asorti(xtick)
comma = 0
for (i = 0; i < len; i += 2) \{
        if (xtick[i] == 0) \{
                i--
                continue
        \}
        printf "%s%d \\"%s\\"", comma ? ", " : " ", xtick[i], tosize(xtick[i] * 32)
        comma = 1
\}
printf "\\n"
\nwused{\\{NW408Gwv-1OqFIM-1}}\nwendcode{}\nwbegindocs{84}\subsection{Generating Inputs}
The following script generates inputs for run-bench.sh. It takes two
arguments: the amount of bytes to generate and the maximum block size. It
assumes 256-bit hashes.

Arguments are taken as powers of two. For example, to generate 16GiB of
hashes with a maximum block size of 4GiB, use the command line below. Note
that $2^{34} = 16 \mathrm{GiB}$ and $2^{31} = 2 \mathrm{GiB}$.
\begin{verbatim}
./generate-inputs.sh 34 31
\end{verbatim}
\nwenddocs{}\nwbegincode{85}\sublabel{NW408Gwv-4doyHE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4doyHE-1}}}\moddef{generate-inputs.sh~{\nwtagstyle{}\subpageref{NW408Gwv-4doyHE-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#!/bin/sh

if [ $# -lt 2 ]
then
        printf 'usage: ./generate-inputs.sh TOTAL_SIZE MAX_BLOCK_SIZE\\n' >&2
        printf '\\tArguments are powers of 2, e.g., 32 gives 2^32 = 16GiB\\n' >&2
        printf '\\t2^0=1 2^1=2 2^2=4 2^3=8 2^4=16 2^5=32 2^6=64 2^7=128 ' >&2
        printf '2^8=256 2^9=512\\n' >&2
        exit 1
fi

total_bytes=$1
max_block_bytes=$2
digest_size_bytes=5 # 256 bits = 32 bytes, 32=2^5

total=$((total_bytes - digest_size_bytes))
max_block=$((max_block_bytes - digest_size_bytes))

for b in $(seq 10 $max_block)
do
        printf '%d\\t%d\\n' $((1 << b)) $((1 << (total - b)))
done
\nwnotused{generate-inputs.sh}\nwendcode{}\nwbegindocs{86}\subsection{Verifying Hashes}
This script generates dumps of hashes generated on the CPU and GPU,
then displays them side-by-side with less(1).
\nwenddocs{}\nwbegincode{87}\sublabel{NW408Gwv-4EDtgt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW408Gwv-4EDtgt-1}}}\moddef{check-dumps.sh~{\nwtagstyle{}\subpageref{NW408Gwv-4EDtgt-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#!/bin/sh
./bench 1024 1024 blake3 serial
mv bench-hashes.dat bench-hashes-serial.txt
./bench 1024 1024 blake3 sycl-cpu
mv bench-hashes.dat bench-hashes-cpu.txt
./bench 1024 1024 blake3 sycl-gpu
mv bench-hashes.dat bench-hashes-gpu.txt
paste bench-hashes-serial.txt bench-hashes-cpu.txt bench-hashes-gpu.txt | less
wc -l bench-hashes-serial.txt bench-hashes-cpu.txt bench-hashes-gpu.txt
\nwnotused{check-dumps.sh}\nwendcode{}\nwbegindocs{88}\section{Index}
\subsection{Chunks}
\nowebchunks
\subsection{Identifiers}
\nowebindex
\nwenddocs{}

\nwixlogsorted{c}{{Additional headers}{NW408Gwv-4b5Gre-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-4b5Gre-1}\nwixd{NW408Gwv-4b5Gre-2}\nwixd{NW408Gwv-4b5Gre-3}\nwixd{NW408Gwv-4b5Gre-4}\nwixd{NW408Gwv-4b5Gre-5}\nwixd{NW408Gwv-4b5Gre-6}}}%
\nwixlogsorted{c}{{bench.cpp}{NW408Gwv-3XORfx-1}{\nwixd{NW408Gwv-3XORfx-1}}}%
\nwixlogsorted{c}{{check-dumps.sh}{NW408Gwv-4EDtgt-1}{\nwixd{NW408Gwv-4EDtgt-1}}}%
\nwixlogsorted{c}{{Convert bytes to human-readable units}{NW408Gwv-9tsGB-1}{\nwixu{NW408Gwv-1OqFIM-1}\nwixd{NW408Gwv-9tsGB-1}}}%
\nwixlogsorted{c}{{Delete any local declarations}{NW408Gwv-2CzAcv-1}{\nwixu{NW408Gwv-17GnJ9-1}\nwixd{NW408Gwv-2CzAcv-1}}}%
\nwixlogsorted{c}{{Dump hashes in \code{}buffer\edoc{}}{NW408Gwv-QdW2c-1}{\nwixu{NW408Gwv-RUfgA-3}\nwixd{NW408Gwv-QdW2c-1}}}%
\nwixlogsorted{c}{{Function definitions}{NW408Gwv-RUfgA-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-RUfgA-1}\nwixd{NW408Gwv-RUfgA-2}\nwixd{NW408Gwv-RUfgA-3}\nwixd{NW408Gwv-RUfgA-4}\nwixd{NW408Gwv-RUfgA-5}\nwixd{NW408Gwv-RUfgA-6}\nwixd{NW408Gwv-RUfgA-7}}}%
\nwixlogsorted{c}{{Function prototypes}{NW408Gwv-G7sOC-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-G7sOC-1}\nwixd{NW408Gwv-G7sOC-2}}}%
\nwixlogsorted{c}{{generate-inputs.sh}{NW408Gwv-4doyHE-1}{\nwixd{NW408Gwv-4doyHE-1}}}%
\nwixlogsorted{c}{{Global variables}{NW408Gwv-20zlE5-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-20zlE5-1}\nwixd{NW408Gwv-20zlE5-2}\nwixd{NW408Gwv-20zlE5-3}\nwixd{NW408Gwv-20zlE5-4}}}%
\nwixlogsorted{c}{{Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with BLAKE3}{NW408Gwv-3e8ivs-1}{\nwixu{NW408Gwv-RUfgA-4}\nwixd{NW408Gwv-3e8ivs-1}}}%
\nwixlogsorted{c}{{Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with SHA-224}{NW408Gwv-JGDkX-1}{\nwixu{NW408Gwv-RUfgA-4}\nwixd{NW408Gwv-JGDkX-1}}}%
\nwixlogsorted{c}{{Hash \code{}input\edoc{} to \code{}buf[slot]\edoc{} with SHA-256}{NW408Gwv-1xDrLN-1}{\nwixu{NW408Gwv-RUfgA-4}\nwixd{NW408Gwv-1xDrLN-1}}}%
\nwixlogsorted{c}{{Local declarations for the runner}{NW408Gwv-4aufMS-1}{\nwixu{NW408Gwv-17GnJ9-1}\nwixd{NW408Gwv-4aufMS-1}}}%
\nwixlogsorted{c}{{Macro definitions}{NW408Gwv-3Yh66L-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-3Yh66L-1}\nwixd{NW408Gwv-3Yh66L-2}}}%
\nwixlogsorted{c}{{Possibly finalize dump}{NW408Gwv-1esTOw-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-1esTOw-1}}}%
\nwixlogsorted{c}{{Possibly initialize dump}{NW408Gwv-45hS38-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-45hS38-1}}}%
\nwixlogsorted{c}{{Print the output}{NW408Gwv-btmOb-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-btmOb-1}}}%
\nwixlogsorted{c}{{Process arguments}{NW408Gwv-3D46Ec-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-3D46Ec-1}\nwixd{NW408Gwv-3D46Ec-2}}}%
\nwixlogsorted{c}{{Run benchmark in serial}{NW408Gwv-gU9OG-1}{\nwixu{NW408Gwv-17GnJ9-1}\nwixd{NW408Gwv-gU9OG-1}}}%
\nwixlogsorted{c}{{Run benchmark with OpenMP}{NW408Gwv-2Cc2Fr-1}{\nwixu{NW408Gwv-17GnJ9-1}\nwixd{NW408Gwv-2Cc2Fr-1}}}%
\nwixlogsorted{c}{{Run benchmark with SYCL on the CPU}{NW408Gwv-3XaOMG-1}{\nwixu{NW408Gwv-17GnJ9-1}\nwixd{NW408Gwv-3XaOMG-1}}}%
\nwixlogsorted{c}{{Run benchmark with SYCL on the GPU}{NW408Gwv-3XaQo0-1}{\nwixu{NW408Gwv-17GnJ9-1}\nwixd{NW408Gwv-3XaQo0-1}}}%
\nwixlogsorted{c}{{Run the benchmark}{NW408Gwv-17GnJ9-1}{\nwixu{NW408Gwv-1xUPJU-1}\nwixd{NW408Gwv-17GnJ9-1}}}%
\nwixlogsorted{c}{{run-bench.sh}{NW408Gwv-2BcZja-1}{\nwixd{NW408Gwv-2BcZja-1}}}%
\nwixlogsorted{c}{{Select and print ticks}{NW408Gwv-1ZFdQI-1}{\nwixu{NW408Gwv-1OqFIM-1}\nwixd{NW408Gwv-1ZFdQI-1}}}%
\nwixlogsorted{c}{{Time the benchmark}{NW408Gwv-1xUPJU-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-1xUPJU-1}}}%
\nwixlogsorted{c}{{to-grap.sh}{NW408Gwv-1OqFIM-1}{\nwixd{NW408Gwv-1OqFIM-1}}}%
\nwixlogsorted{c}{{Type definitions}{NW408Gwv-2eQ5X5-1}{\nwixu{NW408Gwv-3XORfx-1}\nwixd{NW408Gwv-2eQ5X5-1}}}%
\nwixlogsorted{i}{{\nwixident{algorithm}}{algorithm}}%
\nwixlogsorted{i}{{\nwixident{alloc{\_}buffers}}{alloc:unbuffers}}%
\nwixlogsorted{i}{{\nwixident{argc}}{argc}}%
\nwixlogsorted{i}{{\nwixident{argv}}{argv}}%
\nwixlogsorted{i}{{\nwixident{dump}}{dump}}%
\nwixlogsorted{i}{{\nwixident{elapsed}}{elapsed}}%
\nwixlogsorted{i}{{\nwixident{hashes{\_}per{\_}block}}{hashes:unper:unblock}}%
\nwixlogsorted{i}{{\nwixident{main}}{main}}%
\nwixlogsorted{i}{{\nwixident{make{\_}queues}}{make:unqueues}}%
\nwixlogsorted{i}{{\nwixident{method}}{method}}%
\nwixlogsorted{i}{{\nwixident{num{\_}blocks}}{num:unblocks}}%
\nwixlogsorted{i}{{\nwixident{parse{\_}enumerator}}{parse:unenumerator}}%
\nwixlogsorted{i}{{\nwixident{parse{\_}unsigned}}{parse:ununsigned}}%
\nwixlogsorted{i}{{\nwixident{run{\_}hash}}{run:unhash}}%
\nwixlogsorted{i}{{\nwixident{run{\_}sycl}}{run:unsycl}}%
\end{document}

