\section{Benchmarking Program}
This section describes the usage of the benchmarking program and its
source code.
XXX what does the benchmark program do?
The structure of the source file is listed below.
<<bench.cpp>>=
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cstdint>
#include <sycl/sycl.hpp>
<<Additional headers>>
<<Macro definitions>>
<<Type definitions>>
<<Function prototypes>>
<<Global variables>>
<<Function definitions>>
int `main(int `argc, const char **`argv)
{
	<<Process arguments>>
	<<Time the benchmark>>
	<<Print the output>>
	return 0;
}
@ The program supports the following hash algorithms and methods to
generate the hashes.
<<Type definitions>>=
enum algorithm {SHA224, SHA256, BLAKE3};
enum method {SERIAL, SYCL_CPU, SYCL_GPU};
@ The following [[printf]] template is used for printing output to the
standard output.
<<Macro definitions>>=
#define OUTPUT_TEMPLATE "hashes_per_block =\t%u\t" \
	"num_blocks =\t%u\t" \
	"algorithm =\t%s\t" \
	"runner =\t%s\t" \
	"elapsed (s) =\t%f\n"
@
%I didn't end up doing this
%.PP
%If enabled at compile-time, the program will print its hashes on the
%standard error.
%.
%This is intended for debugging purposes.
%.
%It can be enabled by passing PRINT_HASHES=1 to Make when compiling.
@ \subsection{Argument Processing}
This subsection details the code for processing [[argv]].
The arguments listed above are stored in the following global variables,
respectively.
Algorithms and methods are stored using enumerations defined earlier.
<<Global variables>>=
static unsigned `hashes_per_block;
static unsigned `num_blocks;
static enum algorithm `algorithm;
static enum method `method;
@ If the incorrect number of arguments were given, then we print an error
message and exit.
Currently, we are assuming that the user will have access to the
documentation and will be able to find the usage information.
<<Process arguments>>=
if (argc != 5) {
	fprintf(stderr, "%s: incorrect number of arguments.\n", argv[0]);
	return 1;
}
@ Processing each argument takes several function calls.
Also, if there is an error processing the arguments, we want to exit
with an error.
The below functions will handle these tasks.
They both take [[argv]] and the argument within [[argv]] to parse.
The [[parse_enumerator]] function also takes an array of valid enumerators
and the number of valid enumerators; the parsed value is the index of
the enumerator within the array.
Both functions return the parsed value.
<<Function prototypes>>=
static unsigned parse_unsigned(const char **argv, int arg_num);
static int parse_enumerator(const char **argv, int arg_num,
		const char **enumerators, const unsigned num_enumerators);
@ The algorithm and method enumerations both need an array of enumerators
for [[parse_enumerator]].
The order of strings within the array {\tt must} match the order of
enumerators within the enumeration definition.
<<Global variables>>=
static const char *algorithms[] = {"sha224", "sha256", "blake3"};
static const char *methods[] = {"serial", "sycl-cpu", "sycl-gpu"};
@ It will be useful to have a macro to take the length of an array.
<<Macro definitions>>=
#define LENGTH(arr) (sizeof(arr) / sizeof((arr)[0]))
@ C++ wants additional casts for enumerators.
<<Process arguments>>=
hashes_per_block = parse_unsigned(argv, 1);
num_blocks = parse_unsigned(argv, 2);
algorithm = (enum algorithm)
	parse_enumerator(argv, 3, algorithms, LENGTH(algorithms));
method = (enum method)parse_enumerator(argv, 4, methods, LENGTH(algorithms));
@ Parsing integers is simple using C’s [[sscanf]].
If it does not match any inputs items, which is the only case for failure
here, it returns [[EOF]].
It cannot fail before the first match, because there is only one item
to match.
<<Function definitions>>=
static unsigned `parse_unsigned(const char **argv, int arg_num)
{
	int rc;
	unsigned result;
	rc = sscanf(argv[arg_num], "%u", &result);
	if (rc == EOF) {
		fprintf(stderr, "%s: could not parse “%s” as an unsigned "
			"integer\n", argv[0], argv[arg_num]);
		exit(1);
	}
	return result;
}
@ Enumerators are parsed using a linear scan and C’s [[strcmp]].
There are ways to make this more efficient, but it probably does not
matter.
Printing the list of enuemrators as part of the error message is
non-trivial, and possibly unnecessary.
<<Function definitions>>=
static int `parse_enumerator(const char **argv, int arg_num,
		const char **enumerators, const unsigned num_enumerators)
{
	unsigned i;
	for (i = 0; i < num_enumerators; i++)
		if (strcmp(argv[arg_num], enumerators[i]) == 0)
			return i;
	fprintf(stderr, "%s: could not match “%s” to ",
			argv[0], argv[arg_num]);
	for (i = 0; i < num_enumerators - 1; i++)
		fprintf(stderr, "“%s”, ", enumerators[i]);
	fprintf(stderr, "or “%s”.\n", enumerators[i]);
	exit(1);
	return 0;
}
@ \subsection{Timing the Benchmark}
The POSIX clock interface is used to get the time before and after the
hashes are generated.
Since only a relative time is required, [[CLOCK_MONOTONIC]] is sufficient.
The elapsed time is stored in the variable [[elapsed]].
<<Time the benchmark>>=
double elapsed;
struct timespec start, end;
clock_gettime(CLOCK_MONOTONIC, &start);
<<Run the benchmark>>
clock_gettime(CLOCK_MONOTONIC, &end);
`elapsed = (double)end.tv_sec - (double)start.tv_sec;
elapsed += ((double)end.tv_nsec - (double)start.tv_nsec) / 1e12L;
@ \subsection{Printing the Output}
All of the variables that are needed for output have been defined.
The string names for the algorithm and method are printed instead of
their enumerator’s number.
<<Print the output>>=
printf(OUTPUT_TEMPLATE, hashes_per_block, num_blocks,
		algorithms[algorithm], methods[method], elapsed);
@ \subsection{Supporting Different Hash Algorithms}
The goal is to support several different hash algorithms and compare
their performance.
The following function will be used to dispatch the correct hash
function according the algorithm, and ensure the result is written to
[[buf[slot]]].
The algorithm must be passed explicitly, otherwise the SYCL compiler
will complain.
<<Function prototypes>>=
static void run_hash(enum algorithm algorithm, uint64_t input,
		unsigned char *buf, unsigned slot);
@ The downside of this approach is that the algorithm is checked every
time a hash is generated.
This could be avoided by calling a function that is set to the appropriate
hash function, but SYCL does not support calling function pointers in
its kernels.
<<Function definitions>>=
static void `run_hash(enum algorithm algorithm, uint64_t input,
		unsigned char *buf, unsigned slot)
{
	switch (algorithm) {
	case SHA224:
		<<Hash [[input]] to [[buf[slot]]] with SHA-224>>
		break;
	case SHA256:
		<<Hash [[input]] to [[buf[slot]]] with SHA-256>>
		break;
	case BLAKE3:
		<<Hash [[input]] to [[buf[slot]]] with BLAKE3>>
		break;
	}
}
@ \subsection{Supporting Different Running Methods}
The other feature of this program is that it supports several drivers
to run the has generation code.
Some runners may require common, local variables.
<<Run the benchmark>>=
<<Local declarations for the runner>>
switch (method) {
case SERIAL:
	<<Run benchmark in serial>>
	break;
case SYCL_CPU:
	<<Run benchmark with SYCL on the CPU>>
	break;
case SYCL_GPU:
	<<Run benchmark with SYCL on the GPU>>
	break;
}
<<Delete any local declarations>>
@ Something that all of the runners will need is a buffer to write the
hashes to.
This requires knowing the size of each hash in bytes.
They are stored in the [[digest_size]] array.
<<Local declarations for the runner>>=
unsigned char *output_buffer =
		new unsigned char[hashes_per_block * digest_size[algorithm]];
<<Delete any local declarations>>=
delete[] output_buffer;
<<Global variables>>=
static const unsigned digest_size[] = {28u, 32u, 32u};
@ \subsection{Running in Serial}
Running in serial is simple.
<<Run benchmark in serial>>=
for (uint64_t i = 0; i < hashes_per_block * num_blocks; i++)
	run_hash(algorithm, i, output_buffer, i % hashes_per_block);
@ \subsection{Running with SYCL}
Running with SYCL requires a few local variables and polymorphic types.
A separate function is used to deal with this.
<<Function definitions>>=
template <class Selector>
static void `run_sycl(Selector sel, unsigned char *host_buffer)
{
	<<SYCL {\tt using} statements>>
	queue q(sel);
	<<Run benchmark with SYCL>>
}
<<Run benchmark with SYCL on the CPU>>=
run_sycl(sycl::cpu_selector_v, output_buffer);
<<Run benchmark with SYCL on the GPU>>=
run_sycl(sycl::gpu_selector_v, output_buffer);
@ All of SYCL’s identifiers are from the [[sycl]] namespace, but they
do not collide with anything already in scope.
<<SYCL {\tt using} statements>>=
using sycl::event;
using sycl::id;
using sycl::malloc_device;
using sycl::queue;
using sycl::range;
@ Each block of hashes will be offloaded separately, in serial.
SYCL needs its own buffer allocated on the device, [[sycl_buffer]].
TODO: does [[sycl_buffer]] need to be freed somehow?
<<Run benchmark with SYCL>>=
unsigned buffer_size = hashes_per_block * digest_size[algorithm];
unsigned char *sycl_buffer = malloc_device<unsigned char>(buffer_size, q);
<<Ensure [[sycl_buffer]] allocation was successful>>
for (uint64_t i = 0, base = 0; i < num_blocks; i++, base += hashes_per_block) {
	<<Offload hashing and copy back>>
}
@ The call to [[sycl_buffer]] can fail, and it’s painful to debug without
a warning.
<<Ensure [[sycl_buffer]] allocation was successful>>=
if (sycl_buffer == nullptr) {
	fprintf(stderr, "sycl::malloc_device failed when called %u bytes were "
			"requested.\n", buffer_size);
	exit(1);
}
@ Hashes are offloaded with a parallel for loop, and copied back via
[[queue::memcpy]].
The last event, the copy, must be explicitly waited for.
The algorithm must be a local variable, otherwise the SYCL compiler
will complain.
<<Offload hashing and copy back>>=
enum algorithm alg = algorithm;
event hashes_ev = q.parallel_for(range<1>(hashes_per_block), [=] (id<1> idx) {
	run_hash(alg, base + idx, sycl_buffer, idx);
});
event copy_ev = q.memcpy(host_buffer, sycl_buffer, buffer_size, hashes_ev);
copy_ev.wait();
@ \subsection{SHA-224 Hash Algorithm}
The SHA-224 algorithm used here comes from an implementation that I found
online.\footnote{\tt http://www.zedwood.com/article/cpp-sha224-function}
There are some optimizations that could be made with a custom
implementation, because we know exactly how long the message is, etc.
<<Additional headers>>=
#include "sha224.hpp"
@ Using this implementation requires only the following function calls.
The hash algorithms are implemented in [[switch]] case bodies, so a new
scope is needed to declare local variables well.
<<Hash [[input]] to [[buf[slot]]] with SHA-224>>=
{
	class SHA224 ctx;
	ctx.init();
	ctx.update((const unsigned char *)&input, sizeof(input));
	ctx.final(buf + slot * digest_size[algorithm]);
}
@ As it turns out [[SYCL_EXTERNAL]] is not universal, and everything {\tt must}
be in the same translation to be portable across SYCL compilers, it seems.
Although the below strategy works, it’s bad practice and should be
replaced.
<<Additional headers>>=
#include "sha224.cpp"
@ \subsection{SHA-256 Hash Algorithm}
I modified the SHA-224 implementation to be SHA-256.
I have not completely verified that it is correct.
<<Additional headers>>=
#include "sha256.hpp"
<<Hash [[input]] to [[buf[slot]]] with SHA-256>>=
{
	class SHA256 ctx;
	ctx.init();
	ctx.update((const unsigned char *)&input, sizeof(input));
	ctx.final(buf + slot * digest_size[algorithm]);
}
@ See the SHA-224 section for an explanation.
<<Additional headers>>=
#include "sha256.cpp"
@ \subsection{BLAKE3 Hash Algorithm}
The BLAKE3 implementation comes from the BLAKE3 reference implemenation.
It had to be modified slightly to work with C++ and SYCL.
<<Additional headers>>=
#include "blake3.h"
@ The interface for BLAKE3 uses different names and arguments than SHA-2,
but functionally the same otherwise.
<<Hash [[input]] to [[buf[slot]]] with BLAKE3>>=
{
	blake3_hasher hasher;
	blake3_hasher_init(&hasher);
	blake3_hasher_update(&hasher, &input, sizeof(input));
	blake3_hasher_finalize(&hasher,
			buf + slot * digest_size[algorithm],
			digest_size[algorithm]);
}
@ See the SHA-224 section for an explanation.
<<Additional headers>>=
#include "blake3.cpp"
#include "blake3_dispatch.cpp"
#include "blake3_portable.cpp"
@ \subsection{Support Scripts}
The \mbox{run-bench.sh} script automates the collection of data using
the benchmark, and outputs the results to the file \mbox{bench-results}.
It generates 16GiB of hashes using varying block sizes, with SHA-256
and BLAKE3 hashes, and on the CPU and GPU.
TODO check your math on the sizes...

It fails for the huge buffer sizes.
This should be investigated, but it does not appear to affect the
completion of the script or the results.
<<run-bench.sh>>=
#!/bin/sh

while read -r x y
do
	./bench $x $y sha256 sycl-cpu
	./bench $x $y sha256 sycl-gpu
	./bench $x $y blake3 sycl-cpu
	./bench $x $y blake3 sycl-gpu
done <<EOF | tee bench-results
1024	262144
2048	131072
4096	65536
8192	32768
16384	16384
32768	8192
65536	4096
131072	2048
262144	1024
524288	512
1048576	256
2097152	128
4194304	64
8388608	32
16777216	16
33554432	8
67108864	4
134217728	2
268435456	1
EOF
@ The following Haskell program was used to generate the inputs for the
above script, which were manually copied in.
This could be written as a shell script and included in \%run-bench.sh\:,
so no manual copying is needed.
<<Generate inputs>>=
digestSize = div 512 8
blockSizes = [y | x <- [0 .. 34], let y = div (2 ^ x) digestSize, y >= 1024]
maxBlockSize = maximum blockSizes
blockCounts = map (div maxBlockSize) blockSizes
outputs = zipWith (\s c -> shows s ('\t' : show c)) blockSizes blockCounts
main = mapM_ putStrLn outputs
@ The following script can be used to convert the output of the benchmark
script to a grap(1) graph, suitable to {\tt copy} in \mbox{bench.nw}.
See the report source of that file to see how to use the output of
this script.
<<to-grap.sh>>=
#!/bin/sh
echo 'label left "Real Time" "(s)"'
echo 'label bot "Block Size"'
echo 'coord y 0, 22 log x'
echo -n 'ticks bot out at 1024 "64KiB", 4096 "256KiB", 16384 "1MiB", '
echo -n '65536 "4MiB", 262144 "16MiB", 1048576 "64MiB", 4194304 "256MiB", '
echo '16777216 "1GiB", 67108864 "4GiB"'
echo '"\(sq SHA-256, CPU" ljust at (1e6,20)'
echo '"\(pl SHA-256, GPU" ljust at (1e6,19)'
echo '"\(*D BLAKE3, CPU" ljust at (1e6,18)'
echo '"\(mu BLAKE3, GPU" ljust at (1e6,17)'
awk '-F\t' '
	/cpu/ && /sha/ {char = "sq"}
	/gpu/ && /sha/ {char = "pl"}
	/cpu/ && /blake/ {char = "*D"}
	/gpu/ && /blake/ {char = "mu"}
	{printf "\"\\(%s\" at (%f,%f)\n", char, $2, $10}
'
@ \section{Index}
\subsection{Chunks}
\nowebchunks
\subsection{Identifiers}
\nowebindex
